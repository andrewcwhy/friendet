{"version":3,"file":"utils.cjs","sources":["../../src/utils.ts"],"sourcesContent":["import * as Solid from 'solid-js'\n\nexport const useLayoutEffect =\n  typeof window !== 'undefined' ? Solid.createRenderEffect : Solid.createEffect\n\nexport const usePrevious = (fn: () => boolean) => {\n  return Solid.createMemo(\n    (\n      prev: { current: boolean | null; previous: boolean | null } = {\n        current: null,\n        previous: null,\n      },\n    ) => {\n      const current = fn()\n\n      if (prev.current !== current) {\n        prev.previous = prev.current\n        prev.current = current\n      }\n\n      return prev\n    },\n  )\n}\n\n/**\n * React hook to wrap `IntersectionObserver`.\n *\n * This hook will create an `IntersectionObserver` and observe the ref passed to it.\n *\n * When the intersection changes, the callback will be called with the `IntersectionObserverEntry`.\n *\n * @param ref - The ref to observe\n * @param intersectionObserverOptions - The options to pass to the IntersectionObserver\n * @param options - The options to pass to the hook\n * @param callback - The callback to call when the intersection changes\n * @returns The IntersectionObserver instance\n * @example\n * ```tsx\n * const MyComponent = () => {\n * const ref = React.useRef<HTMLDivElement>(null)\n * useIntersectionObserver(\n *  ref,\n *  (entry) => { doSomething(entry) },\n *  { rootMargin: '10px' },\n *  { disabled: false }\n * )\n * return <div ref={ref} />\n * ```\n */\nexport function useIntersectionObserver<T extends Element>(\n  ref: Solid.Accessor<T | null>,\n  callback: (entry: IntersectionObserverEntry | undefined) => void,\n  intersectionObserverOptions: IntersectionObserverInit = {},\n  options: { disabled?: boolean } = {},\n): Solid.Accessor<IntersectionObserver | null> {\n  const isIntersectionObserverAvailable =\n    typeof IntersectionObserver === 'function'\n  let observerRef: IntersectionObserver | null = null\n\n  Solid.createEffect(() => {\n    const r = ref()\n    if (!r || !isIntersectionObserverAvailable || options.disabled) {\n      return\n    }\n\n    observerRef = new IntersectionObserver(([entry]) => {\n      callback(entry)\n    }, intersectionObserverOptions)\n\n    observerRef.observe(r)\n\n    Solid.onCleanup(() => {\n      observerRef?.disconnect()\n    })\n  })\n\n  return () => observerRef\n}\n"],"names":["Solid"],"mappings":";;;;;;;;;;;;;;;;;;;;AAEO,MAAM,kBACX,OAAO,WAAW,cAAcA,iBAAM,qBAAqBA,iBAAM;AAEtD,MAAA,cAAc,CAAC,OAAsB;AAChD,SAAOA,iBAAM;AAAA,IACX,CACE,OAA8D;AAAA,MAC5D,SAAS;AAAA,MACT,UAAU;AAAA,IAAA,MAET;AACH,YAAM,UAAU,GAAG;AAEf,UAAA,KAAK,YAAY,SAAS;AAC5B,aAAK,WAAW,KAAK;AACrB,aAAK,UAAU;AAAA,MAAA;AAGV,aAAA;AAAA,IAAA;AAAA,EAEX;AACF;AA2BgB,SAAA,wBACd,KACA,UACA,8BAAwD,CACxD,GAAA,UAAkC,IACW;AACvC,QAAA,kCACJ,OAAO,yBAAyB;AAClC,MAAI,cAA2C;AAE/CA,mBAAM,aAAa,MAAM;AACvB,UAAM,IAAI,IAAI;AACd,QAAI,CAAC,KAAK,CAAC,mCAAmC,QAAQ,UAAU;AAC9D;AAAA,IAAA;AAGF,kBAAc,IAAI,qBAAqB,CAAC,CAAC,KAAK,MAAM;AAClD,eAAS,KAAK;AAAA,OACb,2BAA2B;AAE9B,gBAAY,QAAQ,CAAC;AAErBA,qBAAM,UAAU,MAAM;AACpB,iDAAa;AAAA,IAAW,CACzB;AAAA,EAAA,CACF;AAED,SAAO,MAAM;AACf;;;;"}