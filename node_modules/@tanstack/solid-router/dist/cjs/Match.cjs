"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const Solid = require("solid-js/web");
const Solid$1 = require("solid-js");
const invariant = require("tiny-invariant");
const warning = require("tiny-warning");
const routerCore = require("@tanstack/router-core");
const CatchBoundary = require("./CatchBoundary.cjs");
const useRouterState = require("./useRouterState.cjs");
const useRouter = require("./useRouter.cjs");
const notFound = require("./not-found.cjs");
const matchContext = require("./matchContext.cjs");
const SafeFragment = require("./SafeFragment.cjs");
const renderRouteNotFound = require("./renderRouteNotFound.cjs");
const scrollRestoration = require("./scroll-restoration.cjs");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const Solid__namespace = /* @__PURE__ */ _interopNamespaceDefault(Solid$1);
const Match = (props) => {
  const router = useRouter.useRouter();
  const routeId = useRouterState.useRouterState({
    select: (s) => {
      var _a;
      return (_a = s.matches.find((d) => d.id === props.matchId)) == null ? void 0 : _a.routeId;
    }
  });
  invariant(routeId, `Could not find routeId for matchId "${props.matchId}". Please file an issue!`);
  const route = () => router.routesById[routeId()];
  const PendingComponent = () => route().options.pendingComponent ?? router.options.defaultPendingComponent;
  const routeErrorComponent = () => route().options.errorComponent ?? router.options.defaultErrorComponent;
  const routeOnCatch = () => route().options.onCatch ?? router.options.defaultOnCatch;
  const routeNotFoundComponent = () => {
    var _a;
    return route().isRoot ? (
      // If it's the root route, use the globalNotFound option, with fallback to the notFoundRoute's component
      route().options.notFoundComponent ?? ((_a = router.options.notFoundRoute) == null ? void 0 : _a.options.component)
    ) : route().options.notFoundComponent;
  };
  const ResolvedSuspenseBoundary = () => {
    var _a;
    return (
      // If we're on the root route, allow forcefully wrapping in suspense
      (!route().isRoot || route().options.wrapInSuspense) && (route().options.wrapInSuspense ?? PendingComponent() ?? ((_a = route().options.errorComponent) == null ? void 0 : _a.preload)) ? Solid__namespace.Suspense : SafeFragment.SafeFragment
    );
  };
  const ResolvedCatchBoundary = () => routeErrorComponent() ? CatchBoundary.CatchBoundary : SafeFragment.SafeFragment;
  const ResolvedNotFoundBoundary = () => routeNotFoundComponent() ? notFound.CatchNotFound : SafeFragment.SafeFragment;
  const resetKey = useRouterState.useRouterState({
    select: (s) => s.loadedAt
  });
  const parentRouteId = useRouterState.useRouterState({
    select: (s) => {
      var _a;
      const index = s.matches.findIndex((d) => d.id === props.matchId);
      return (_a = s.matches[index - 1]) == null ? void 0 : _a.routeId;
    }
  });
  const ShellComponent = route().isRoot ? route().options.shellComponent ?? SafeFragment.SafeFragment : SafeFragment.SafeFragment;
  return Solid.createComponent(ShellComponent, {
    get children() {
      return [Solid.createComponent(matchContext.matchContext.Provider, {
        value: () => props.matchId,
        get children() {
          return Solid.createComponent(Solid.Dynamic, {
            get component() {
              return ResolvedSuspenseBoundary();
            },
            get fallback() {
              return Solid.createComponent(Solid.Dynamic, {
                get component() {
                  return PendingComponent();
                }
              });
            },
            get children() {
              return Solid.createComponent(Solid.Dynamic, {
                get component() {
                  return ResolvedCatchBoundary();
                },
                getResetKey: () => resetKey(),
                get errorComponent() {
                  return routeErrorComponent() || CatchBoundary.ErrorComponent;
                },
                onCatch: (error) => {
                  var _a;
                  if (routerCore.isNotFound(error)) throw error;
                  warning(false, `Error in route match: ${props.matchId}`);
                  (_a = routeOnCatch()) == null ? void 0 : _a(error);
                },
                get children() {
                  return Solid.createComponent(Solid.Dynamic, {
                    get component() {
                      return ResolvedNotFoundBoundary();
                    },
                    fallback: (error) => {
                      if (!routeNotFoundComponent() || error.routeId && error.routeId !== routeId || !error.routeId && !route().isRoot) throw error;
                      return Solid.createComponent(Solid.Dynamic, Solid.mergeProps({
                        get component() {
                          return routeNotFoundComponent();
                        }
                      }, error));
                    },
                    get children() {
                      return Solid.createComponent(MatchInner, {
                        get matchId() {
                          return props.matchId;
                        }
                      });
                    }
                  });
                }
              });
            }
          });
        }
      }), Solid.memo(() => Solid.memo(() => parentRouteId() === routerCore.rootRouteId)() ? [Solid.createComponent(OnRendered, {}), Solid.createComponent(scrollRestoration.ScrollRestoration, {})] : null)];
    }
  });
};
function OnRendered() {
  const router = useRouter.useRouter();
  const location = useRouterState.useRouterState({
    select: (s) => {
      var _a;
      return (_a = s.resolvedLocation) == null ? void 0 : _a.state.__TSR_key;
    }
  });
  Solid__namespace.createEffect(Solid__namespace.on([location], () => {
    router.emit({
      type: "onRendered",
      ...routerCore.getLocationChangeInfo(router.state)
    });
  }));
  return null;
}
const MatchInner = (props) => {
  const router = useRouter.useRouter();
  const matchState = useRouterState.useRouterState({
    select: (s) => {
      const matchIndex = s.matches.findIndex((d) => d.id === props.matchId);
      const match2 = s.matches[matchIndex];
      const routeId = match2.routeId;
      const remountFn = router.routesById[routeId].options.remountDeps ?? router.options.defaultRemountDeps;
      const remountDeps = remountFn == null ? void 0 : remountFn({
        routeId,
        loaderDeps: match2.loaderDeps,
        params: match2._strictParams,
        search: match2._strictSearch
      });
      const key = remountDeps ? JSON.stringify(remountDeps) : void 0;
      return {
        key,
        routeId,
        match: routerCore.pick(match2, ["id", "status", "error"])
      };
    }
  });
  const route = () => router.routesById[matchState().routeId];
  const match = () => matchState().match;
  const out = () => {
    const Comp = route().options.component ?? router.options.defaultComponent;
    if (Comp) {
      return Solid.createComponent(Comp, {});
    }
    return Solid.createComponent(Outlet, {});
  };
  return Solid.createComponent(Solid__namespace.Switch, {
    get children() {
      return [Solid.createComponent(Solid__namespace.Match, {
        get when() {
          return match().status === "notFound";
        },
        children: (_) => {
          invariant(routerCore.isNotFound(match().error), "Expected a notFound error");
          return renderRouteNotFound.renderRouteNotFound(router, route(), match().error);
        }
      }), Solid.createComponent(Solid__namespace.Match, {
        get when() {
          return match().status === "redirected";
        },
        children: (_) => {
          invariant(routerCore.isRedirect(match().error), "Expected a redirect error");
          const [loaderResult] = Solid__namespace.createResource(async () => {
            var _a;
            await new Promise((r) => setTimeout(r, 0));
            return (_a = router.getMatch(match().id)) == null ? void 0 : _a.loadPromise;
          });
          return Solid.memo(loaderResult);
        }
      }), Solid.createComponent(Solid__namespace.Match, {
        get when() {
          return match().status === "error";
        },
        children: (_) => {
          if (router.isServer) {
            const RouteErrorComponent = (route().options.errorComponent ?? router.options.defaultErrorComponent) || CatchBoundary.ErrorComponent;
            return Solid.createComponent(RouteErrorComponent, {
              get error() {
                return match().error;
              },
              info: {
                componentStack: ""
              }
            });
          }
          throw match().error;
        }
      }), Solid.createComponent(Solid__namespace.Match, {
        get when() {
          return match().status === "pending";
        },
        children: (_) => {
          var _a;
          const pendingMinMs = route().options.pendingMinMs ?? router.options.defaultPendingMinMs;
          if (pendingMinMs && !((_a = router.getMatch(match().id)) == null ? void 0 : _a.minPendingPromise)) {
            if (!router.isServer) {
              const minPendingPromise = routerCore.createControlledPromise();
              Promise.resolve().then(() => {
                router.updateMatch(match().id, (prev) => ({
                  ...prev,
                  minPendingPromise
                }));
              });
              setTimeout(() => {
                minPendingPromise.resolve();
                router.updateMatch(match().id, (prev) => ({
                  ...prev,
                  minPendingPromise: void 0
                }));
              }, pendingMinMs);
            }
          }
          const [loaderResult] = Solid__namespace.createResource(async () => {
            var _a2;
            await new Promise((r) => setTimeout(r, 0));
            return (_a2 = router.getMatch(match().id)) == null ? void 0 : _a2.loadPromise;
          });
          return Solid.memo(loaderResult);
        }
      }), Solid.createComponent(Solid__namespace.Match, {
        get when() {
          return match().status === "success";
        },
        get children() {
          return out();
        }
      })];
    }
  });
};
const Outlet = () => {
  const router = useRouter.useRouter();
  const matchId = Solid__namespace.useContext(matchContext.matchContext);
  const routeId = useRouterState.useRouterState({
    select: (s) => {
      var _a;
      return (_a = s.matches.find((d) => d.id === matchId())) == null ? void 0 : _a.routeId;
    }
  });
  const route = () => router.routesById[routeId()];
  const parentGlobalNotFound = useRouterState.useRouterState({
    select: (s) => {
      const matches = s.matches;
      const parentMatch = matches.find((d) => d.id === matchId());
      invariant(parentMatch, `Could not find parent match for matchId "${matchId()}"`);
      return parentMatch.globalNotFound;
    }
  });
  const childMatchId = useRouterState.useRouterState({
    select: (s) => {
      var _a;
      const matches = s.matches;
      const index = matches.findIndex((d) => d.id === matchId());
      const v = (_a = matches[index + 1]) == null ? void 0 : _a.id;
      return v;
    }
  });
  return Solid.createComponent(Solid__namespace.Switch, {
    get children() {
      return [Solid.createComponent(Solid__namespace.Match, {
        get when() {
          return router.isShell;
        },
        get children() {
          return Solid.createComponent(Solid__namespace.Suspense, {
            get fallback() {
              return Solid.createComponent(Solid.Dynamic, {
                get component() {
                  return router.options.defaultPendingComponent;
                }
              });
            },
            get children() {
              return Solid.createComponent(CatchBoundary.ErrorComponent, {
                error: new Error("ShellBoundaryError")
              });
            }
          });
        }
      }), Solid.createComponent(Solid__namespace.Match, {
        get when() {
          return parentGlobalNotFound();
        },
        get children() {
          return renderRouteNotFound.renderRouteNotFound(router, route(), void 0);
        }
      }), Solid.createComponent(Solid__namespace.Match, {
        get when() {
          return childMatchId();
        },
        children: (matchId2) => {
          return Solid.createComponent(Solid__namespace.Show, {
            get when() {
              return matchId2() === routerCore.rootRouteId;
            },
            get fallback() {
              return Solid.createComponent(Match, {
                get matchId() {
                  return matchId2();
                }
              });
            },
            get children() {
              return Solid.createComponent(Solid__namespace.Suspense, {
                get fallback() {
                  return Solid.createComponent(Solid.Dynamic, {
                    get component() {
                      return router.options.defaultPendingComponent;
                    }
                  });
                },
                get children() {
                  return Solid.createComponent(Match, {
                    get matchId() {
                      return matchId2();
                    }
                  });
                }
              });
            }
          });
        }
      })];
    }
  });
};
exports.Match = Match;
exports.MatchInner = MatchInner;
exports.Outlet = Outlet;
//# sourceMappingURL=Match.cjs.map
