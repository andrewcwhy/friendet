{"version":3,"file":"HeadContent.cjs","sources":["../../src/HeadContent.tsx"],"sourcesContent":["import * as Solid from 'solid-js'\nimport { MetaProvider } from '@solidjs/meta'\nimport { Asset } from './Asset'\nimport { useRouter } from './useRouter'\nimport { useRouterState } from './useRouterState'\nimport type { RouterManagedTag } from '@tanstack/router-core'\n\nexport const useTags = () => {\n  const router = useRouter()\n\n  const routeMeta = useRouterState({\n    select: (state) => {\n      return state.matches.map((match) => match.meta!).filter(Boolean)\n    },\n  })\n\n  const meta: Solid.Accessor<Array<RouterManagedTag>> = Solid.createMemo(() => {\n    const resultMeta: Array<RouterManagedTag> = []\n    const metaByAttribute: Record<string, true> = {}\n    let title: RouterManagedTag | undefined\n    ;[...routeMeta()].reverse().forEach((metas) => {\n      ;[...metas].reverse().forEach((m) => {\n        if (!m) return\n\n        if (m.title) {\n          if (!title) {\n            title = {\n              tag: 'title',\n              children: m.title,\n            }\n          }\n        } else {\n          const attribute = m.name ?? m.property\n          if (attribute) {\n            if (metaByAttribute[attribute]) {\n              return\n            } else {\n              metaByAttribute[attribute] = true\n            }\n          }\n\n          resultMeta.push({\n            tag: 'meta',\n            attrs: {\n              ...m,\n            },\n          })\n        }\n      })\n    })\n\n    if (title) {\n      resultMeta.push(title)\n    }\n\n    resultMeta.reverse()\n\n    return resultMeta\n  })\n\n  const links = useRouterState({\n    select: (state) => {\n      const constructed = state.matches\n        .map((match) => match.links!)\n        .filter(Boolean)\n        .flat(1)\n        .map((link) => ({\n          tag: 'link',\n          attrs: {\n            ...link,\n          },\n        })) satisfies Array<RouterManagedTag>\n\n      const manifest = router.ssr?.manifest\n\n      // These are the assets extracted from the ViteManifest\n      // using the `startManifestPlugin`\n      const assets = state.matches\n        .map((match) => manifest?.routes[match.routeId]?.assets ?? [])\n        .filter(Boolean)\n        .flat(1)\n        .filter((asset) => asset.tag === 'link')\n        .map(\n          (asset) =>\n            ({\n              tag: 'link',\n              attrs: asset.attrs,\n            }) satisfies RouterManagedTag,\n        )\n\n      return [...constructed, ...assets]\n    },\n  })\n\n  const preloadMeta = useRouterState({\n    select: (state) => {\n      const preloadMeta: Array<RouterManagedTag> = []\n\n      state.matches\n        .map((match) => router.looseRoutesById[match.routeId]!)\n        .forEach((route) =>\n          router.ssr?.manifest?.routes[route.id]?.preloads\n            ?.filter(Boolean)\n            .forEach((preload) => {\n              preloadMeta.push({\n                tag: 'link',\n                attrs: {\n                  rel: 'modulepreload',\n                  href: preload,\n                },\n              })\n            }),\n        )\n\n      return preloadMeta\n    },\n  })\n\n  const headScripts = useRouterState({\n    select: (state) =>\n      (\n        state.matches\n          .map((match) => match.headScripts!)\n          .flat(1)\n          .filter(Boolean) as Array<RouterManagedTag>\n      ).map(({ children, ...script }) => ({\n        tag: 'script',\n        attrs: {\n          ...script,\n        },\n        children,\n      })),\n  })\n\n  return () =>\n    uniqBy(\n      [\n        ...meta(),\n        ...preloadMeta(),\n        ...links(),\n        ...headScripts(),\n      ] as Array<RouterManagedTag>,\n      (d) => {\n        return JSON.stringify(d)\n      },\n    )\n}\n\n/**\n * @description The `HeadContent` component is used to render meta tags, links, and scripts for the current route.\n * It should be rendered in the `<head>` of your document.\n */\nexport function HeadContent() {\n  const tags = useTags()\n  return (\n    <MetaProvider>\n      {tags().map((tag) => (\n        <Asset {...tag} />\n      ))}\n    </MetaProvider>\n  )\n}\n\nfunction uniqBy<T>(arr: Array<T>, fn: (item: T) => string) {\n  const seen = new Set<string>()\n  return arr.filter((item) => {\n    const key = fn(item)\n    if (seen.has(key)) {\n      return false\n    }\n    seen.add(key)\n    return true\n  })\n}\n"],"names":["useTags","router","useRouter","routeMeta","useRouterState","select","state","matches","map","match","meta","filter","Boolean","Solid","createMemo","resultMeta","metaByAttribute","title","reverse","forEach","metas","m","tag","children","attribute","name","property","push","attrs","links","constructed","flat","link","manifest","ssr","assets","routes","routeId","asset","preloadMeta","looseRoutesById","route","id","preloads","preload","rel","href","headScripts","script","uniqBy","d","JSON","stringify","HeadContent","tags","_$createComponent","MetaProvider","Asset","arr","fn","seen","Set","item","key","has","add"],"mappings":"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"}