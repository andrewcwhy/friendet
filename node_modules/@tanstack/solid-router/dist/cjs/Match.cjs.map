{"version":3,"file":"Match.cjs","sources":["../../src/Match.tsx"],"sourcesContent":["import * as Solid from 'solid-js'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport {\n  createControlledPromise,\n  getLocationChangeInfo,\n  isNotFound,\n  isRedirect,\n  pick,\n  rootRouteId,\n} from '@tanstack/router-core'\nimport { Dynamic } from 'solid-js/web'\nimport { CatchBoundary, ErrorComponent } from './CatchBoundary'\nimport { useRouterState } from './useRouterState'\nimport { useRouter } from './useRouter'\nimport { CatchNotFound } from './not-found'\nimport { matchContext } from './matchContext'\nimport { SafeFragment } from './SafeFragment'\nimport { renderRouteNotFound } from './renderRouteNotFound'\nimport { ScrollRestoration } from './scroll-restoration'\nimport type { AnyRoute, RootRouteOptions } from '@tanstack/router-core'\n\nexport const Match = (props: { matchId: string }) => {\n  const router = useRouter()\n  const routeId = useRouterState({\n    select: (s) => {\n      return s.matches.find((d) => d.id === props.matchId)?.routeId as string\n    },\n  })\n\n  invariant(\n    routeId,\n    `Could not find routeId for matchId \"${props.matchId}\". Please file an issue!`,\n  )\n\n  const route: () => AnyRoute = () => router.routesById[routeId()]\n\n  const PendingComponent = () =>\n    route().options.pendingComponent ?? router.options.defaultPendingComponent\n\n  const routeErrorComponent = () =>\n    route().options.errorComponent ?? router.options.defaultErrorComponent\n\n  const routeOnCatch = () =>\n    route().options.onCatch ?? router.options.defaultOnCatch\n\n  const routeNotFoundComponent = () =>\n    route().isRoot\n      ? // If it's the root route, use the globalNotFound option, with fallback to the notFoundRoute's component\n        (route().options.notFoundComponent ??\n        router.options.notFoundRoute?.options.component)\n      : route().options.notFoundComponent\n\n  const ResolvedSuspenseBoundary = () =>\n    // If we're on the root route, allow forcefully wrapping in suspense\n    (!route().isRoot || route().options.wrapInSuspense) &&\n    (route().options.wrapInSuspense ??\n      PendingComponent() ??\n      (route().options.errorComponent as any)?.preload)\n      ? Solid.Suspense\n      : SafeFragment\n\n  const ResolvedCatchBoundary = () =>\n    routeErrorComponent() ? CatchBoundary : SafeFragment\n\n  const ResolvedNotFoundBoundary = () =>\n    routeNotFoundComponent() ? CatchNotFound : SafeFragment\n\n  const resetKey = useRouterState({\n    select: (s) => s.loadedAt,\n  })\n\n  const parentRouteId = useRouterState({\n    select: (s) => {\n      const index = s.matches.findIndex((d) => d.id === props.matchId)\n      return s.matches[index - 1]?.routeId as string\n    },\n  })\n\n  const ShellComponent = route().isRoot\n    ? ((route().options as RootRouteOptions).shellComponent ?? SafeFragment)\n    : SafeFragment\n\n  return (\n    <ShellComponent>\n      <matchContext.Provider value={() => props.matchId}>\n        <Dynamic\n          component={ResolvedSuspenseBoundary()}\n          fallback={<Dynamic component={PendingComponent()} />}\n        >\n          <Dynamic\n            component={ResolvedCatchBoundary()}\n            getResetKey={() => resetKey()}\n            errorComponent={routeErrorComponent() || ErrorComponent}\n            onCatch={(error: Error) => {\n              // Forward not found errors (we don't want to show the error component for these)\n              if (isNotFound(error)) throw error\n              warning(false, `Error in route match: ${props.matchId}`)\n              routeOnCatch()?.(error)\n            }}\n          >\n            <Dynamic\n              component={ResolvedNotFoundBoundary()}\n              fallback={(error: any) => {\n                // If the current not found handler doesn't exist or it has a\n                // route ID which doesn't match the current route, rethrow the error\n                if (\n                  !routeNotFoundComponent() ||\n                  (error.routeId && error.routeId !== routeId) ||\n                  (!error.routeId && !route().isRoot)\n                )\n                  throw error\n\n                return (\n                  <Dynamic component={routeNotFoundComponent()} {...error} />\n                )\n              }}\n            >\n              <MatchInner matchId={props.matchId} />\n            </Dynamic>\n          </Dynamic>\n        </Dynamic>\n      </matchContext.Provider>\n\n      {parentRouteId() === rootRouteId ? (\n        <>\n          <OnRendered />\n          <ScrollRestoration />\n        </>\n      ) : null}\n    </ShellComponent>\n  )\n}\n\n// On Rendered can't happen above the root layout because it actually\n// renders a dummy dom element to track the rendered state of the app.\n// We render a script tag with a key that changes based on the current\n// location state.__TSR_key. Also, because it's below the root layout, it\n// allows us to fire onRendered events even after a hydration mismatch\n// error that occurred above the root layout (like bad head/link tags,\n// which is common).\nfunction OnRendered() {\n  const router = useRouter()\n\n  const location = useRouterState({\n    select: (s) => {\n      return s.resolvedLocation?.state.__TSR_key\n    },\n  })\n  Solid.createEffect(\n    Solid.on([location], () => {\n      router.emit({\n        type: 'onRendered',\n        ...getLocationChangeInfo(router.state),\n      })\n    }),\n  )\n  return null\n}\n\nexport const MatchInner = (props: { matchId: string }): any => {\n  const router = useRouter()\n\n  // { match, key, routeId } =\n  const matchState: Solid.Accessor<any> = useRouterState({\n    select: (s) => {\n      const matchIndex = s.matches.findIndex((d) => d.id === props.matchId)\n      const match = s.matches[matchIndex]!\n      const routeId = match.routeId as string\n\n      const remountFn =\n        (router.routesById[routeId] as AnyRoute).options.remountDeps ??\n        router.options.defaultRemountDeps\n      const remountDeps = remountFn?.({\n        routeId,\n        loaderDeps: match.loaderDeps,\n        params: match._strictParams,\n        search: match._strictSearch,\n      })\n      const key = remountDeps ? JSON.stringify(remountDeps) : undefined\n\n      return {\n        key,\n        routeId,\n        match: pick(match, ['id', 'status', 'error']),\n      }\n    },\n  })\n\n  const route = () => router.routesById[matchState().routeId]!\n\n  // function useChangedDiff(value: any) {\n  //   const ref = Solid.useRef(value)\n  //   const changed = ref.current !== value\n  //   if (changed) {\n  //     console.log(\n  //       'Changed:',\n  //       value,\n  //       Object.fromEntries(\n  //         Object.entries(value).filter(\n  //           ([key, val]) => val !== ref.current[key],\n  //         ),\n  //       ),\n  //     )\n  //   }\n  //   ref.current = value\n  // }\n\n  // useChangedDiff(match)\n  const match = () => matchState().match\n\n  const out = () => {\n    const Comp = route().options.component ?? router.options.defaultComponent\n    if (Comp) {\n      return <Comp />\n    }\n    return <Outlet />\n  }\n\n  return (\n    <Solid.Switch>\n      <Solid.Match when={match().status === 'notFound'}>\n        {(_) => {\n          invariant(isNotFound(match().error), 'Expected a notFound error')\n\n          return renderRouteNotFound(router, route(), match().error)\n        }}\n      </Solid.Match>\n      <Solid.Match when={match().status === 'redirected'}>\n        {(_) => {\n          invariant(isRedirect(match().error), 'Expected a redirect error')\n\n          const [loaderResult] = Solid.createResource(async () => {\n            await new Promise((r) => setTimeout(r, 0))\n            return router.getMatch(match().id)?.loadPromise\n          })\n\n          return <>{loaderResult()}</>\n        }}\n      </Solid.Match>\n      <Solid.Match when={match().status === 'error'}>\n        {(_) => {\n          if (router.isServer) {\n            const RouteErrorComponent =\n              (route().options.errorComponent ??\n                router.options.defaultErrorComponent) ||\n              ErrorComponent\n\n            return (\n              <RouteErrorComponent\n                error={match().error}\n                info={{\n                  componentStack: '',\n                }}\n              />\n            )\n          }\n\n          throw match().error\n        }}\n      </Solid.Match>\n      <Solid.Match when={match().status === 'pending'}>\n        {(_) => {\n          const pendingMinMs =\n            route().options.pendingMinMs ?? router.options.defaultPendingMinMs\n\n          if (pendingMinMs && !router.getMatch(match().id)?.minPendingPromise) {\n            // Create a promise that will resolve after the minPendingMs\n            if (!router.isServer) {\n              const minPendingPromise = createControlledPromise<void>()\n\n              Promise.resolve().then(() => {\n                router.updateMatch(match().id, (prev) => ({\n                  ...prev,\n                  minPendingPromise,\n                }))\n              })\n\n              setTimeout(() => {\n                minPendingPromise.resolve()\n\n                // We've handled the minPendingPromise, so we can delete it\n                router.updateMatch(match().id, (prev) => ({\n                  ...prev,\n                  minPendingPromise: undefined,\n                }))\n              }, pendingMinMs)\n            }\n          }\n\n          const [loaderResult] = Solid.createResource(async () => {\n            await new Promise((r) => setTimeout(r, 0))\n            return router.getMatch(match().id)?.loadPromise\n          })\n\n          return <>{loaderResult()}</>\n        }}\n      </Solid.Match>\n      <Solid.Match when={match().status === 'success'}>{out()}</Solid.Match>\n    </Solid.Switch>\n  )\n}\n\nexport const Outlet = () => {\n  const router = useRouter()\n  const matchId = Solid.useContext(matchContext)\n  const routeId = useRouterState({\n    select: (s) => s.matches.find((d) => d.id === matchId())?.routeId as string,\n  })\n\n  const route = () => router.routesById[routeId()]!\n\n  const parentGlobalNotFound = useRouterState({\n    select: (s) => {\n      const matches = s.matches\n      const parentMatch = matches.find((d) => d.id === matchId())\n      invariant(\n        parentMatch,\n        `Could not find parent match for matchId \"${matchId()}\"`,\n      )\n      return parentMatch.globalNotFound\n    },\n  })\n\n  const childMatchId = useRouterState({\n    select: (s) => {\n      const matches = s.matches\n      const index = matches.findIndex((d) => d.id === matchId())\n      const v = matches[index + 1]?.id\n      return v\n    },\n  })\n\n  return (\n    <Solid.Switch>\n      <Solid.Match when={router.isShell}>\n        <Solid.Suspense\n          fallback={\n            <Dynamic component={router.options.defaultPendingComponent} />\n          }\n        >\n          <ErrorComponent error={new Error('ShellBoundaryError')} />\n        </Solid.Suspense>\n      </Solid.Match>\n\n      <Solid.Match when={parentGlobalNotFound()}>\n        {renderRouteNotFound(router, route(), undefined)}\n      </Solid.Match>\n      <Solid.Match when={childMatchId()}>\n        {(matchId) => {\n          // const nextMatch = <Match matchId={matchId()} />\n\n          return (\n            <Solid.Show\n              when={matchId() === rootRouteId}\n              fallback={<Match matchId={matchId()} />}\n            >\n              <Solid.Suspense\n                fallback={\n                  <Dynamic component={router.options.defaultPendingComponent} />\n                }\n              >\n                <Match matchId={matchId()} />\n              </Solid.Suspense>\n            </Solid.Show>\n          )\n        }}\n      </Solid.Match>\n    </Solid.Switch>\n  )\n}\n"],"names":["Match","props","router","useRouter","routeId","useRouterState","select","s","matches","find","d","id","matchId","invariant","route","routesById","PendingComponent","options","pendingComponent","defaultPendingComponent","routeErrorComponent","errorComponent","defaultErrorComponent","routeOnCatch","onCatch","defaultOnCatch","routeNotFoundComponent","isRoot","notFoundComponent","notFoundRoute","component","ResolvedSuspenseBoundary","wrapInSuspense","preload","Solid","Suspense","SafeFragment","ResolvedCatchBoundary","CatchBoundary","ResolvedNotFoundBoundary","CatchNotFound","resetKey","loadedAt","parentRouteId","index","findIndex","ShellComponent","shellComponent","_$createComponent","children","matchContext","Provider","value","Dynamic","fallback","getResetKey","ErrorComponent","error","isNotFound","warning","_$mergeProps","MatchInner","_$memo","rootRouteId","OnRendered","ScrollRestoration","location","resolvedLocation","state","__TSR_key","createEffect","on","emit","type","getLocationChangeInfo","matchState","matchIndex","match","remountFn","remountDeps","defaultRemountDeps","loaderDeps","params","_strictParams","search","_strictSearch","key","JSON","stringify","undefined","pick","out","Comp","defaultComponent","Outlet","Switch","when","status","_","renderRouteNotFound","isRedirect","loaderResult","createResource","Promise","r","setTimeout","getMatch","loadPromise","isServer","RouteErrorComponent","info","componentStack","pendingMinMs","defaultPendingMinMs","minPendingPromise","createControlledPromise","resolve","then","updateMatch","prev","useContext","parentGlobalNotFound","parentMatch","globalNotFound","childMatchId","v","isShell","Error","Show"],"mappings":"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"}