import * as Solid from 'solid-js';
import warning from 'tiny-warning';
import { CatchBoundary, ErrorComponent } from './CatchBoundary';
import { useRouterState } from './useRouterState';
import { useRouter } from './useRouter';
import { Transitioner } from './Transitioner';
import { matchContext } from './matchContext';
import { Match } from './Match';
import { SafeFragment } from './SafeFragment';
export function Matches() {
    const router = useRouter();
    const pendingElement = router.options.defaultPendingComponent ? (<router.options.defaultPendingComponent />) : null;
    // Do not render a root Suspense during SSR or hydrating from SSR
    const ResolvedSuspense = router.isServer || (typeof document !== 'undefined' && router.clientSsr)
        ? SafeFragment
        : Solid.Suspense;
    const inner = (<ResolvedSuspense fallback={pendingElement}>
      <Transitioner />
      <MatchesInner />
    </ResolvedSuspense>);
    return router.options.InnerWrap ? (<router.options.InnerWrap>{inner}</router.options.InnerWrap>) : (inner);
}
function MatchesInner() {
    const matchId = useRouterState({
        select: (s) => {
            return s.matches[0]?.id;
        },
    });
    const resetKey = useRouterState({
        select: (s) => s.loadedAt,
    });
    return (<matchContext.Provider value={matchId}>
      <CatchBoundary getResetKey={() => resetKey()} errorComponent={ErrorComponent} onCatch={(error) => {
            warning(false, `The following error wasn't caught by any route! At the very least, consider setting an 'errorComponent' in your RootRoute!`);
            warning(false, error.message || error.toString());
        }}>
        {matchId() ? <Match matchId={matchId()}/> : null}
      </CatchBoundary>
    </matchContext.Provider>);
}
export function useMatchRoute() {
    const router = useRouter();
    const status = useRouterState({
        select: (s) => s.status,
    });
    return (opts) => {
        const { pending, caseSensitive, fuzzy, includeSearch, ...rest } = opts;
        const matchRoute = Solid.createMemo(() => {
            status();
            return router.matchRoute(rest, {
                pending,
                caseSensitive,
                fuzzy,
                includeSearch,
            });
        });
        return matchRoute;
    };
}
export function MatchRoute(props) {
    const status = useRouterState({
        select: (s) => s.status,
    });
    return (<Solid.Show when={status()} keyed>
      {(_) => {
            const matchRoute = useMatchRoute();
            const params = matchRoute(props)();
            const child = props.children;
            if (typeof child === 'function') {
                return child(params);
            }
            return params ? child : null;
        }}
    </Solid.Show>);
}
export function useMatches(opts) {
    return useRouterState({
        select: (state) => {
            const matches = state.matches;
            return opts?.select
                ? opts.select(matches)
                : matches;
        },
    });
}
export function useParentMatches(opts) {
    const contextMatchId = Solid.useContext(matchContext);
    return useMatches({
        select: (matches) => {
            matches = matches.slice(0, matches.findIndex((d) => d.id === contextMatchId()));
            return opts?.select ? opts.select(matches) : matches;
        },
    });
}
export function useChildMatches(opts) {
    const contextMatchId = Solid.useContext(matchContext);
    return useMatches({
        select: (matches) => {
            matches = matches.slice(matches.findIndex((d) => d.id === contextMatchId()) + 1);
            return opts?.select ? opts.select(matches) : matches;
        },
    });
}
//# sourceMappingURL=Matches.jsx.map