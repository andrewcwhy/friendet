import * as Solid from 'solid-js';
import { mergeRefs } from '@solid-primitives/refs';
import { deepEqual, exactPathTest, functionalUpdate, preloadWarning, removeTrailingSlash, } from '@tanstack/router-core';
import { Dynamic } from 'solid-js/web';
import { useRouterState } from './useRouterState';
import { useRouter } from './useRouter';
import { useIntersectionObserver } from './utils';
import { useMatch } from './useMatch';
export function useLinkProps(options) {
    const router = useRouter();
    const [isTransitioning, setIsTransitioning] = Solid.createSignal(false);
    let hasRenderFetched = false;
    const [local, rest] = Solid.splitProps(Solid.mergeProps({
        activeProps: () => ({ class: 'active' }),
        inactiveProps: () => ({}),
    }, options), [
        'activeProps',
        'inactiveProps',
        'activeOptions',
        'to',
        'preload',
        'preloadDelay',
        'hashScrollIntoView',
        'replace',
        'startTransition',
        'resetScroll',
        'viewTransition',
        'target',
        'disabled',
        'style',
        'class',
        'onClick',
        'onFocus',
        'onMouseEnter',
        'onMouseLeave',
        'onMouseOver',
        'onMouseOut',
        'onTouchStart',
        'ignoreBlocker',
    ]);
    // const {
    //   // custom props
    //   activeProps = () => ({ class: 'active' }),
    //   inactiveProps = () => ({}),
    //   activeOptions,
    //   to,
    //   preload: userPreload,
    //   preloadDelay: userPreloadDelay,
    //   hashScrollIntoView,
    //   replace,
    //   startTransition,
    //   resetScroll,
    //   viewTransition,
    //   // element props
    //   children,
    //   target,
    //   disabled,
    //   style,
    //   class,
    //   onClick,
    //   onFocus,
    //   onMouseEnter,
    //   onMouseLeave,
    //   onTouchStart,
    //   ignoreBlocker,
    //   ...rest
    // } = options
    const [_, propsSafeToSpread] = Solid.splitProps(rest, [
        'params',
        'search',
        'hash',
        'state',
        'mask',
        'reloadDocument',
        'unsafeRelative',
    ]);
    // If this link simply reloads the current route,
    // make sure it has a new key so it will trigger a data refresh
    // If this `to` is a valid external URL, return
    // null for LinkUtils
    const type = () => {
        try {
            new URL(`${local.to}`);
            return 'external';
        }
        catch { }
        return 'internal';
    };
    const currentSearch = useRouterState({
        select: (s) => s.location.searchStr,
    });
    // when `from` is not supplied, use the route of the current match as the `from` location
    // so relative routing works as expected
    const from = useMatch({
        strict: false,
        select: (match) => options.from ?? match.fullPath,
    });
    const _options = () => ({
        ...options,
        from: from(),
    });
    const next = Solid.createMemo(() => {
        currentSearch();
        return router.buildLocation(_options());
    });
    const preload = Solid.createMemo(() => {
        if (_options().reloadDocument) {
            return false;
        }
        return local.preload ?? router.options.defaultPreload;
    });
    const preloadDelay = () => local.preloadDelay ?? router.options.defaultPreloadDelay ?? 0;
    const isActive = useRouterState({
        select: (s) => {
            if (local.activeOptions?.exact) {
                const testExact = exactPathTest(s.location.pathname, next().pathname, router.basepath);
                if (!testExact) {
                    return false;
                }
            }
            else {
                const currentPathSplit = removeTrailingSlash(s.location.pathname, router.basepath).split('/');
                const nextPathSplit = removeTrailingSlash(next()?.pathname, router.basepath)?.split('/');
                const pathIsFuzzyEqual = nextPathSplit?.every((d, i) => d === currentPathSplit[i]);
                if (!pathIsFuzzyEqual) {
                    return false;
                }
            }
            if (local.activeOptions?.includeSearch ?? true) {
                const searchTest = deepEqual(s.location.search, next().search, {
                    partial: !local.activeOptions?.exact,
                    ignoreUndefined: !local.activeOptions?.explicitUndefined,
                });
                if (!searchTest) {
                    return false;
                }
            }
            if (local.activeOptions?.includeHash) {
                return s.location.hash === next().hash;
            }
            return true;
        },
    });
    const doPreload = () => router.preloadRoute(_options()).catch((err) => {
        console.warn(err);
        console.warn(preloadWarning);
    });
    const preloadViewportIoCallback = (entry) => {
        if (entry?.isIntersecting) {
            doPreload();
        }
    };
    const [ref, setRef] = Solid.createSignal(null);
    useIntersectionObserver(ref, preloadViewportIoCallback, { rootMargin: '100px' }, { disabled: !!local.disabled || !(preload() === 'viewport') });
    Solid.createEffect(() => {
        if (hasRenderFetched) {
            return;
        }
        if (!local.disabled && preload() === 'render') {
            doPreload();
            hasRenderFetched = true;
        }
    });
    if (type() === 'external') {
        return Solid.mergeProps(propsSafeToSpread, {
            ref,
            get type() {
                return type();
            },
            get href() {
                return local.to;
            },
        }, Solid.splitProps(local, [
            'target',
            'disabled',
            'style',
            'class',
            'onClick',
            'onFocus',
            'onMouseEnter',
            'onMouseLeave',
            'onMouseOut',
            'onMouseOver',
            'onTouchStart',
        ])[0]);
    }
    // The click handler
    const handleClick = (e) => {
        if (!local.disabled &&
            !isCtrlEvent(e) &&
            !e.defaultPrevented &&
            (!local.target || local.target === '_self') &&
            e.button === 0) {
            e.preventDefault();
            setIsTransitioning(true);
            const unsub = router.subscribe('onResolved', () => {
                unsub();
                setIsTransitioning(false);
            });
            // All is well? Navigate!
            // N.B. we don't call `router.commitLocation(next) here because we want to run `validateSearch` before committing
            return router.navigate({
                ..._options(),
                replace: local.replace,
                resetScroll: local.resetScroll,
                hashScrollIntoView: local.hashScrollIntoView,
                startTransition: local.startTransition,
                viewTransition: local.viewTransition,
                ignoreBlocker: local.ignoreBlocker,
            });
        }
    };
    // The click handler
    const handleFocus = (_) => {
        if (local.disabled)
            return;
        if (preload()) {
            doPreload();
        }
    };
    const handleTouchStart = handleFocus;
    const handleEnter = (e) => {
        if (local.disabled)
            return;
        const eventTarget = (e.target || {});
        if (preload()) {
            if (eventTarget.preloadTimeout) {
                return;
            }
            eventTarget.preloadTimeout = setTimeout(() => {
                eventTarget.preloadTimeout = null;
                doPreload();
            }, preloadDelay());
        }
    };
    const handleLeave = (e) => {
        if (local.disabled)
            return;
        const eventTarget = (e.target || {});
        if (eventTarget.preloadTimeout) {
            clearTimeout(eventTarget.preloadTimeout);
            eventTarget.preloadTimeout = null;
        }
    };
    /** Call a JSX.EventHandlerUnion with the event. */
    function callHandler(event, handler) {
        if (handler) {
            if (typeof handler === 'function') {
                handler(event);
            }
            else {
                handler[0](handler[1], event);
            }
        }
        return event.defaultPrevented;
    }
    function composeEventHandlers(handlers) {
        return (event) => {
            for (const handler of handlers) {
                callHandler(event, handler);
            }
        };
    }
    // Get the active props
    const resolvedActiveProps = () => isActive() ? (functionalUpdate(local.activeProps, {}) ?? {}) : {};
    // Get the inactive props
    const resolvedInactiveProps = () => isActive() ? {} : functionalUpdate(local.inactiveProps, {});
    const resolvedClassName = () => [local.class, resolvedActiveProps().class, resolvedInactiveProps().class]
        .filter(Boolean)
        .join(' ');
    const resolvedStyle = () => ({
        ...local.style,
        ...resolvedActiveProps().style,
        ...resolvedInactiveProps().style,
    });
    const href = Solid.createMemo(() => {
        const nextLocation = next();
        const maskedLocation = nextLocation?.maskedLocation;
        return _options().disabled
            ? undefined
            : maskedLocation
                ? router.history.createHref(maskedLocation.href)
                : router.history.createHref(nextLocation?.href);
    });
    return Solid.mergeProps(propsSafeToSpread, resolvedActiveProps, resolvedInactiveProps, () => {
        return {
            href: href(),
            ref: mergeRefs(setRef, _options().ref),
            onClick: composeEventHandlers([local.onClick, handleClick]),
            onFocus: composeEventHandlers([local.onFocus, handleFocus]),
            onMouseEnter: composeEventHandlers([local.onMouseEnter, handleEnter]),
            onMouseOver: composeEventHandlers([local.onMouseOver, handleEnter]),
            onMouseLeave: composeEventHandlers([local.onMouseLeave, handleLeave]),
            onMouseOut: composeEventHandlers([local.onMouseOut, handleLeave]),
            onTouchStart: composeEventHandlers([
                local.onTouchStart,
                handleTouchStart,
            ]),
            disabled: !!local.disabled,
            target: local.target,
            ...(Object.keys(resolvedStyle).length && { style: resolvedStyle }),
            ...(resolvedClassName() && { class: resolvedClassName() }),
            ...(local.disabled && {
                role: 'link',
                'aria-disabled': true,
            }),
            ...(isActive() && { 'data-status': 'active', 'aria-current': 'page' }),
            ...(isTransitioning() && { 'data-transitioning': 'transitioning' }),
        };
    });
}
export function createLink(Comp) {
    return (props) => <Link {...props} _asChild={Comp}/>;
}
export const Link = (props) => {
    const [local, rest] = Solid.splitProps(props, ['_asChild', 'children']);
    const [_, linkProps] = Solid.splitProps(useLinkProps(rest), ['type']);
    const children = Solid.createMemo(() => {
        const ch = local.children;
        if (typeof ch === 'function') {
            return ch({
                get isActive() {
                    return linkProps['data-status'] === 'active';
                },
                isTransitioning: false,
            });
        }
        return ch;
    });
    return (<Dynamic component={local._asChild ? local._asChild : 'a'} {...linkProps}>
      {children()}
    </Dynamic>);
};
function isCtrlEvent(e) {
    return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}
export const linkOptions = (options) => {
    return options;
};
//# sourceMappingURL=link.jsx.map