import { createComponent, mergeProps, Dynamic } from "solid-js/web";
import * as Solid from "solid-js";
import { mergeRefs } from "@solid-primitives/refs";
import { functionalUpdate, preloadWarning, exactPathTest, removeTrailingSlash, deepEqual } from "@tanstack/router-core";
import { useRouterState } from "./useRouterState.js";
import { useRouter } from "./useRouter.js";
import { useIntersectionObserver } from "./utils.js";
import { useMatch } from "./useMatch.js";
function useLinkProps(options) {
  const router = useRouter();
  const [isTransitioning, setIsTransitioning] = Solid.createSignal(false);
  let hasRenderFetched = false;
  const [local, rest] = Solid.splitProps(Solid.mergeProps({
    activeProps: () => ({
      class: "active"
    }),
    inactiveProps: () => ({})
  }, options), ["activeProps", "inactiveProps", "activeOptions", "to", "preload", "preloadDelay", "hashScrollIntoView", "replace", "startTransition", "resetScroll", "viewTransition", "target", "disabled", "style", "class", "onClick", "onFocus", "onMouseEnter", "onMouseLeave", "onMouseOver", "onMouseOut", "onTouchStart", "ignoreBlocker"]);
  const [_, propsSafeToSpread] = Solid.splitProps(rest, ["params", "search", "hash", "state", "mask", "reloadDocument", "unsafeRelative"]);
  const type = () => {
    try {
      new URL(`${local.to}`);
      return "external";
    } catch {
    }
    return "internal";
  };
  const currentSearch = useRouterState({
    select: (s) => s.location.searchStr
  });
  const from = useMatch({
    strict: false,
    select: (match) => options.from ?? match.fullPath
  });
  const _options = () => ({
    ...options,
    from: from()
  });
  const next = Solid.createMemo(() => {
    currentSearch();
    return router.buildLocation(_options());
  });
  const preload = Solid.createMemo(() => {
    if (_options().reloadDocument) {
      return false;
    }
    return local.preload ?? router.options.defaultPreload;
  });
  const preloadDelay = () => local.preloadDelay ?? router.options.defaultPreloadDelay ?? 0;
  const isActive = useRouterState({
    select: (s) => {
      var _a, _b, _c, _d, _e, _f, _g;
      if ((_a = local.activeOptions) == null ? void 0 : _a.exact) {
        const testExact = exactPathTest(s.location.pathname, next().pathname, router.basepath);
        if (!testExact) {
          return false;
        }
      } else {
        const currentPathSplit = removeTrailingSlash(s.location.pathname, router.basepath).split("/");
        const nextPathSplit = (_c = removeTrailingSlash((_b = next()) == null ? void 0 : _b.pathname, router.basepath)) == null ? void 0 : _c.split("/");
        const pathIsFuzzyEqual = nextPathSplit == null ? void 0 : nextPathSplit.every((d, i) => d === currentPathSplit[i]);
        if (!pathIsFuzzyEqual) {
          return false;
        }
      }
      if (((_d = local.activeOptions) == null ? void 0 : _d.includeSearch) ?? true) {
        const searchTest = deepEqual(s.location.search, next().search, {
          partial: !((_e = local.activeOptions) == null ? void 0 : _e.exact),
          ignoreUndefined: !((_f = local.activeOptions) == null ? void 0 : _f.explicitUndefined)
        });
        if (!searchTest) {
          return false;
        }
      }
      if ((_g = local.activeOptions) == null ? void 0 : _g.includeHash) {
        return s.location.hash === next().hash;
      }
      return true;
    }
  });
  const doPreload = () => router.preloadRoute(_options()).catch((err) => {
    console.warn(err);
    console.warn(preloadWarning);
  });
  const preloadViewportIoCallback = (entry) => {
    if (entry == null ? void 0 : entry.isIntersecting) {
      doPreload();
    }
  };
  const [ref, setRef] = Solid.createSignal(null);
  useIntersectionObserver(ref, preloadViewportIoCallback, {
    rootMargin: "100px"
  }, {
    disabled: !!local.disabled || !(preload() === "viewport")
  });
  Solid.createEffect(() => {
    if (hasRenderFetched) {
      return;
    }
    if (!local.disabled && preload() === "render") {
      doPreload();
      hasRenderFetched = true;
    }
  });
  if (type() === "external") {
    return Solid.mergeProps(propsSafeToSpread, {
      ref,
      get type() {
        return type();
      },
      get href() {
        return local.to;
      }
    }, Solid.splitProps(local, ["target", "disabled", "style", "class", "onClick", "onFocus", "onMouseEnter", "onMouseLeave", "onMouseOut", "onMouseOver", "onTouchStart"])[0]);
  }
  const handleClick = (e) => {
    if (!local.disabled && !isCtrlEvent(e) && !e.defaultPrevented && (!local.target || local.target === "_self") && e.button === 0) {
      e.preventDefault();
      setIsTransitioning(true);
      const unsub = router.subscribe("onResolved", () => {
        unsub();
        setIsTransitioning(false);
      });
      return router.navigate({
        ..._options(),
        replace: local.replace,
        resetScroll: local.resetScroll,
        hashScrollIntoView: local.hashScrollIntoView,
        startTransition: local.startTransition,
        viewTransition: local.viewTransition,
        ignoreBlocker: local.ignoreBlocker
      });
    }
  };
  const handleFocus = (_2) => {
    if (local.disabled) return;
    if (preload()) {
      doPreload();
    }
  };
  const handleTouchStart = handleFocus;
  const handleEnter = (e) => {
    if (local.disabled) return;
    const eventTarget = e.target || {};
    if (preload()) {
      if (eventTarget.preloadTimeout) {
        return;
      }
      eventTarget.preloadTimeout = setTimeout(() => {
        eventTarget.preloadTimeout = null;
        doPreload();
      }, preloadDelay());
    }
  };
  const handleLeave = (e) => {
    if (local.disabled) return;
    const eventTarget = e.target || {};
    if (eventTarget.preloadTimeout) {
      clearTimeout(eventTarget.preloadTimeout);
      eventTarget.preloadTimeout = null;
    }
  };
  function callHandler(event, handler) {
    if (handler) {
      if (typeof handler === "function") {
        handler(event);
      } else {
        handler[0](handler[1], event);
      }
    }
    return event.defaultPrevented;
  }
  function composeEventHandlers(handlers) {
    return (event) => {
      for (const handler of handlers) {
        callHandler(event, handler);
      }
    };
  }
  const resolvedActiveProps = () => isActive() ? functionalUpdate(local.activeProps, {}) ?? {} : {};
  const resolvedInactiveProps = () => isActive() ? {} : functionalUpdate(local.inactiveProps, {});
  const resolvedClassName = () => [local.class, resolvedActiveProps().class, resolvedInactiveProps().class].filter(Boolean).join(" ");
  const resolvedStyle = () => ({
    ...local.style,
    ...resolvedActiveProps().style,
    ...resolvedInactiveProps().style
  });
  const href = Solid.createMemo(() => {
    const nextLocation = next();
    const maskedLocation = nextLocation == null ? void 0 : nextLocation.maskedLocation;
    return _options().disabled ? void 0 : maskedLocation ? router.history.createHref(maskedLocation.href) : router.history.createHref(nextLocation == null ? void 0 : nextLocation.href);
  });
  return Solid.mergeProps(propsSafeToSpread, resolvedActiveProps, resolvedInactiveProps, () => {
    return {
      href: href(),
      ref: mergeRefs(setRef, _options().ref),
      onClick: composeEventHandlers([local.onClick, handleClick]),
      onFocus: composeEventHandlers([local.onFocus, handleFocus]),
      onMouseEnter: composeEventHandlers([local.onMouseEnter, handleEnter]),
      onMouseOver: composeEventHandlers([local.onMouseOver, handleEnter]),
      onMouseLeave: composeEventHandlers([local.onMouseLeave, handleLeave]),
      onMouseOut: composeEventHandlers([local.onMouseOut, handleLeave]),
      onTouchStart: composeEventHandlers([local.onTouchStart, handleTouchStart]),
      disabled: !!local.disabled,
      target: local.target,
      ...Object.keys(resolvedStyle).length && {
        style: resolvedStyle
      },
      ...resolvedClassName() && {
        class: resolvedClassName()
      },
      ...local.disabled && {
        role: "link",
        "aria-disabled": true
      },
      ...isActive() && {
        "data-status": "active",
        "aria-current": "page"
      },
      ...isTransitioning() && {
        "data-transitioning": "transitioning"
      }
    };
  });
}
function createLink(Comp) {
  return (props) => createComponent(Link, mergeProps(props, {
    _asChild: Comp
  }));
}
const Link = (props) => {
  const [local, rest] = Solid.splitProps(props, ["_asChild", "children"]);
  const [_, linkProps] = Solid.splitProps(useLinkProps(rest), ["type"]);
  const children = Solid.createMemo(() => {
    const ch = local.children;
    if (typeof ch === "function") {
      return ch({
        get isActive() {
          return linkProps["data-status"] === "active";
        },
        isTransitioning: false
      });
    }
    return ch;
  });
  return createComponent(Dynamic, mergeProps({
    get component() {
      return local._asChild ? local._asChild : "a";
    }
  }, linkProps, {
    get children() {
      return children();
    }
  }));
};
function isCtrlEvent(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}
const linkOptions = (options) => {
  return options;
};
export {
  Link,
  createLink,
  linkOptions,
  useLinkProps
};
//# sourceMappingURL=link.js.map
