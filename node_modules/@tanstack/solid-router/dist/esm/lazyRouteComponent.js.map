{"version":3,"file":"lazyRouteComponent.js","sources":["../../src/lazyRouteComponent.tsx"],"sourcesContent":["import { Dynamic } from 'solid-js/web'\nimport { createResource } from 'solid-js'\nimport { Outlet } from './Match'\nimport { ClientOnly } from './ClientOnly'\nimport type { AsyncRouteComponent } from './route'\n\n// If the load fails due to module not found, it may mean a new version of\n// the build was deployed and the user's browser is still using an old version.\n// If this happens, the old version in the user's browser would have an outdated\n// URL to the lazy module.\n// In that case, we want to attempt one window refresh to get the latest.\nfunction isModuleNotFoundError(error: any): boolean {\n  return (\n    typeof error?.message === 'string' &&\n    /Failed to fetch dynamically imported module/.test(error.message)\n  )\n}\n\nexport function lazyRouteComponent<\n  T extends Record<string, any>,\n  TKey extends keyof T = 'default',\n>(\n  importer: () => Promise<T>,\n  exportName?: TKey,\n  ssr?: () => boolean,\n): T[TKey] extends (props: infer TProps) => any\n  ? AsyncRouteComponent<TProps>\n  : never {\n  let loadPromise: Promise<any> | undefined\n  let comp: T[TKey] | T['default']\n  let error: any\n\n  const load = () => {\n    if (typeof document === 'undefined' && ssr?.() === false) {\n      comp = (() => null) as any\n      return Promise.resolve(comp)\n    }\n    if (!loadPromise) {\n      loadPromise = importer()\n        .then((res) => {\n          loadPromise = undefined\n          comp = res[exportName ?? 'default']\n          return comp\n        })\n        .catch((err) => {\n          error = err\n        })\n    }\n\n    return loadPromise\n  }\n\n  const lazyComp = function Lazy(props: any) {\n    // Now that we're out of preload and into actual render path,\n    // throw the error if it was a module not found error during preload\n    if (error) {\n      if (isModuleNotFoundError(error)) {\n        // We don't want an error thrown from preload in this case, because\n        // there's nothing we want to do about module not found during preload.\n        // Record the error, recover the promise with a null return,\n        // and we will attempt module not found resolution during the render path.\n\n        if (\n          error instanceof Error &&\n          typeof window !== 'undefined' &&\n          typeof sessionStorage !== 'undefined'\n        ) {\n          // Again, we want to reload one time on module not found error and not enter\n          // a reload loop if there is some other issue besides an old deploy.\n          // That's why we store our reload attempt in sessionStorage.\n          // Use error.message as key because it contains the module path that failed.\n          const storageKey = `tanstack_router_reload:${error.message}`\n          if (!sessionStorage.getItem(storageKey)) {\n            sessionStorage.setItem(storageKey, '1')\n            window.location.reload()\n\n            // Return empty component while we wait for window to reload\n            return {\n              default: () => null,\n            }\n          }\n        }\n      }\n\n      // Otherwise, just throw the error\n      throw error\n    }\n\n    if (!comp) {\n      const [compResource] = createResource(load, {\n        initialValue: comp,\n        ssrLoadFrom: 'initial',\n      })\n      return <>{compResource()}</>\n    }\n\n    if (ssr?.() === false) {\n      return (\n        <ClientOnly fallback={<Outlet />}>\n          <Dynamic component={comp} {...props} />\n        </ClientOnly>\n      )\n    }\n    return <Dynamic component={comp} {...props} />\n  }\n\n  ;(lazyComp as any).preload = load\n\n  return lazyComp as any\n}\n"],"names":["isModuleNotFoundError","error","message","test","lazyRouteComponent","importer","exportName","ssr","loadPromise","comp","load","document","Promise","resolve","then","res","undefined","catch","err","lazyComp","Lazy","props","Error","window","sessionStorage","storageKey","getItem","setItem","location","reload","default","compResource","createResource","initialValue","ssrLoadFrom","_$memo","_$createComponent","ClientOnly","fallback","Outlet","children","Dynamic","_$mergeProps","component","preload"],"mappings":";;;;AAWA,SAASA,sBAAsBC,OAAqB;AAClD,SACE,QAAOA,+BAAOC,aAAY,YAC1B,8CAA8CC,KAAKF,MAAMC,OAAO;AAEpE;AAEgBE,SAAAA,mBAIdC,UACAC,YACAC,KAGQ;AACJC,MAAAA;AACAC,MAAAA;AACAR,MAAAA;AAEJ,QAAMS,OAAOA,MAAM;AACjB,QAAI,OAAOC,aAAa,gBAAeJ,kCAAY,OAAO;AACxDE,aAAQ,MAAM;AACPG,aAAAA,QAAQC,QAAQJ,IAAI;AAAA,IAAA;AAE7B,QAAI,CAACD,aAAa;AACFH,oBAAAA,SAAAA,EACXS,KAAMC,CAAQ,QAAA;AACCC,sBAAAA;AACPD,eAAAA,IAAIT,cAAc,SAAS;AAC3BG,eAAAA;AAAAA,MAAAA,CACR,EACAQ,MAAOC,CAAQ,QAAA;AACNA,gBAAAA;AAAAA,MAAAA,CACT;AAAA,IAAA;AAGEV,WAAAA;AAAAA,EACT;AAEMW,QAAAA,WAAW,SAASC,KAAKC,OAAY;AAGzC,QAAIpB,OAAO;AACLD,UAAAA,sBAAsBC,KAAK,GAAG;AAMhC,YACEA,iBAAiBqB,SACjB,OAAOC,WAAW,eAClB,OAAOC,mBAAmB,aAC1B;AAKMC,gBAAAA,aAAa,0BAA0BxB,MAAMC,OAAO;AAC1D,cAAI,CAACsB,eAAeE,QAAQD,UAAU,GAAG;AACxBE,2BAAAA,QAAQF,YAAY,GAAG;AACtCF,mBAAOK,SAASC,OAAO;AAGhB,mBAAA;AAAA,cACLC,SAASA,MAAM;AAAA,YACjB;AAAA,UAAA;AAAA,QACF;AAAA,MACF;AAII7B,YAAAA;AAAAA,IAAAA;AAGR,QAAI,CAACQ,MAAM;AACT,YAAM,CAACsB,YAAY,IAAIC,eAAetB,MAAM;AAAA,QAC1CuB,cAAcxB;AAAAA,QACdyB,aAAa;AAAA,MAAA,CACd;AACD,aAAAC,KAAUJ,YAAY;AAAA,IAAA;AAGpBxB,SAAAA,kCAAY,OAAO;AACrB,aAAA6B,gBACGC,YAAU;AAAA,QAAA,IAACC,WAAQ;AAAAF,iBAAAA,gBAAGG,QAAM,EAAA;AAAA,QAAA;AAAA,QAAA,IAAAC,WAAA;AAAAJ,iBAAAA,gBAC1BK,SAAOC,WAAA;AAAA,YAACC,WAAWlC;AAAAA,UAAI,GAAMY,KAAK,CAAA;AAAA,QAAA;AAAA,MAAA,CAAA;AAAA,IAAA;AAIzCe,WAAAA,gBAAQK,SAAOC,WAAA;AAAA,MAACC,WAAWlC;AAAAA,IAAI,GAAMY,KAAK,CAAA;AAAA,EAC5C;AAEEF,WAAiByB,UAAUlC;AAEtBS,SAAAA;AACT;"}