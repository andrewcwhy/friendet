import { createComponent, memo } from "solid-js/web";
import * as Solid from "solid-js";
import warning from "tiny-warning";
import { CatchBoundary, ErrorComponent } from "./CatchBoundary.js";
import { useRouterState } from "./useRouterState.js";
import { useRouter } from "./useRouter.js";
import { Transitioner } from "./Transitioner.js";
import { matchContext } from "./matchContext.js";
import { Match } from "./Match.js";
import { SafeFragment } from "./SafeFragment.js";
function Matches() {
  const router = useRouter();
  const pendingElement = router.options.defaultPendingComponent ? createComponent(router.options.defaultPendingComponent, {}) : null;
  const ResolvedSuspense = router.isServer || typeof document !== "undefined" && router.clientSsr ? SafeFragment : Solid.Suspense;
  const inner = createComponent(ResolvedSuspense, {
    fallback: pendingElement,
    get children() {
      return [createComponent(Transitioner, {}), createComponent(MatchesInner, {})];
    }
  });
  return router.options.InnerWrap ? createComponent(router.options.InnerWrap, {
    children: inner
  }) : inner;
}
function MatchesInner() {
  const matchId = useRouterState({
    select: (s) => {
      var _a;
      return (_a = s.matches[0]) == null ? void 0 : _a.id;
    }
  });
  const resetKey = useRouterState({
    select: (s) => s.loadedAt
  });
  return createComponent(matchContext.Provider, {
    value: matchId,
    get children() {
      return createComponent(CatchBoundary, {
        getResetKey: () => resetKey(),
        errorComponent: ErrorComponent,
        onCatch: (error) => {
          warning(false, `The following error wasn't caught by any route! At the very least, consider setting an 'errorComponent' in your RootRoute!`);
          warning(false, error.message || error.toString());
        },
        get children() {
          return memo(() => !!matchId())() ? createComponent(Match, {
            get matchId() {
              return matchId();
            }
          }) : null;
        }
      });
    }
  });
}
function useMatchRoute() {
  const router = useRouter();
  const status = useRouterState({
    select: (s) => s.status
  });
  return (opts) => {
    const {
      pending,
      caseSensitive,
      fuzzy,
      includeSearch,
      ...rest
    } = opts;
    const matchRoute = Solid.createMemo(() => {
      status();
      return router.matchRoute(rest, {
        pending,
        caseSensitive,
        fuzzy,
        includeSearch
      });
    });
    return matchRoute;
  };
}
function MatchRoute(props) {
  const status = useRouterState({
    select: (s) => s.status
  });
  return createComponent(Solid.Show, {
    get when() {
      return status();
    },
    keyed: true,
    children: (_) => {
      const matchRoute = useMatchRoute();
      const params = matchRoute(props)();
      const child = props.children;
      if (typeof child === "function") {
        return child(params);
      }
      return params ? child : null;
    }
  });
}
function useMatches(opts) {
  return useRouterState({
    select: (state) => {
      const matches = state.matches;
      return (opts == null ? void 0 : opts.select) ? opts.select(matches) : matches;
    }
  });
}
function useParentMatches(opts) {
  const contextMatchId = Solid.useContext(matchContext);
  return useMatches({
    select: (matches) => {
      matches = matches.slice(0, matches.findIndex((d) => d.id === contextMatchId()));
      return (opts == null ? void 0 : opts.select) ? opts.select(matches) : matches;
    }
  });
}
function useChildMatches(opts) {
  const contextMatchId = Solid.useContext(matchContext);
  return useMatches({
    select: (matches) => {
      matches = matches.slice(matches.findIndex((d) => d.id === contextMatchId()) + 1);
      return (opts == null ? void 0 : opts.select) ? opts.select(matches) : matches;
    }
  });
}
export {
  MatchRoute,
  Matches,
  useChildMatches,
  useMatchRoute,
  useMatches,
  useParentMatches
};
//# sourceMappingURL=Matches.js.map
