import { memo } from "solid-js/web";
import * as Solid from "solid-js";
import { useRouter } from "./useRouter.js";
function _resolveBlockerOpts(opts, condition) {
  if (opts === void 0) {
    return {
      shouldBlockFn: () => true,
      withResolver: false
    };
  }
  if ("shouldBlockFn" in opts) {
    return opts;
  }
  if (typeof opts === "function") {
    const shouldBlock2 = Boolean(condition ?? true);
    const _customBlockerFn2 = async () => {
      if (shouldBlock2) return await opts();
      return false;
    };
    return {
      shouldBlockFn: _customBlockerFn2,
      enableBeforeUnload: shouldBlock2,
      withResolver: false
    };
  }
  const shouldBlock = Solid.createMemo(() => Boolean(opts.condition ?? true));
  const _customBlockerFn = async () => {
    if (shouldBlock() && opts.blockerFn !== void 0) {
      return await opts.blockerFn();
    }
    return shouldBlock();
  };
  return {
    get shouldBlockFn() {
      return _customBlockerFn;
    },
    get enableBeforeUnload() {
      return shouldBlock();
    },
    get withResolver() {
      return opts.blockerFn === void 0;
    }
  };
}
function useBlocker(opts, condition) {
  const props = Solid.mergeProps({
    enableBeforeUnload: true,
    disabled: false,
    withResolver: false
  }, _resolveBlockerOpts(opts, condition));
  const router = useRouter();
  const [resolver, setResolver] = Solid.createSignal({
    status: "idle",
    current: void 0,
    next: void 0,
    action: void 0,
    proceed: void 0,
    reset: void 0
  });
  Solid.createEffect(() => {
    const blockerFnComposed = async (blockerFnArgs) => {
      function getLocation(location) {
        const parsedLocation = router.parseLocation(void 0, location);
        const matchedRoutes = router.getMatchedRoutes(parsedLocation.pathname, void 0);
        if (matchedRoutes.foundRoute === void 0) {
          throw new Error(`No route found for location ${location.href}`);
        }
        return {
          routeId: matchedRoutes.foundRoute.id,
          fullPath: matchedRoutes.foundRoute.fullPath,
          pathname: parsedLocation.pathname,
          params: matchedRoutes.routeParams,
          search: parsedLocation.search
        };
      }
      const current = getLocation(blockerFnArgs.currentLocation);
      const next = getLocation(blockerFnArgs.nextLocation);
      const shouldBlock = await props.shouldBlockFn({
        action: blockerFnArgs.action,
        current,
        next
      });
      if (!props.withResolver) {
        return shouldBlock;
      }
      if (!shouldBlock) {
        return false;
      }
      const promise = new Promise((resolve) => {
        setResolver({
          status: "blocked",
          current,
          next,
          action: blockerFnArgs.action,
          proceed: () => resolve(false),
          reset: () => resolve(true)
        });
      });
      const canNavigateAsync = await promise;
      setResolver({
        status: "idle",
        current: void 0,
        next: void 0,
        action: void 0,
        proceed: void 0,
        reset: void 0
      });
      return canNavigateAsync;
    };
    const disposeBlock = props.disabled ? void 0 : router.history.block({
      blockerFn: blockerFnComposed,
      enableBeforeUnload: props.enableBeforeUnload
    });
    Solid.onCleanup(() => disposeBlock == null ? void 0 : disposeBlock());
  });
  return resolver;
}
const _resolvePromptBlockerArgs = (props) => {
  if ("shouldBlockFn" in props) {
    return props;
  }
  const shouldBlock = Solid.createMemo(() => Boolean(props.condition ?? true));
  const _customBlockerFn = async () => {
    if (shouldBlock() && props.blockerFn !== void 0) {
      return await props.blockerFn();
    }
    return shouldBlock;
  };
  return {
    shouldBlockFn: _customBlockerFn,
    get enableBeforeUnload() {
      return shouldBlock();
    },
    get withResolver() {
      return props.blockerFn === void 0;
    }
  };
};
function Block(opts) {
  const [propsWithChildren, rest] = Solid.splitProps(opts, ["children"]);
  const args = _resolvePromptBlockerArgs(rest);
  const resolver = useBlocker(args);
  const children = Solid.createMemo(() => {
    const child = propsWithChildren.children;
    if (resolver && typeof child === "function") return child(resolver());
    return child;
  });
  return memo(children);
}
export {
  Block,
  useBlocker
};
//# sourceMappingURL=useBlocker.js.map
