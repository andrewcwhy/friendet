{"version":3,"file":"Matches.js","sources":["../../src/Matches.tsx"],"sourcesContent":["import * as Solid from 'solid-js'\nimport warning from 'tiny-warning'\nimport { CatchBoundary, ErrorComponent } from './CatchBoundary'\nimport { useRouterState } from './useRouterState'\nimport { useRouter } from './useRouter'\nimport { Transitioner } from './Transitioner'\nimport { matchContext } from './matchContext'\nimport { Match } from './Match'\nimport { SafeFragment } from './SafeFragment'\nimport type {\n  AnyRouter,\n  DeepPartial,\n  Expand,\n  MakeOptionalPathParams,\n  MakeOptionalSearchParams,\n  MakeRouteMatchUnion,\n  MaskOptions,\n  MatchRouteOptions,\n  NoInfer,\n  RegisteredRouter,\n  ResolveRelativePath,\n  ResolveRoute,\n  RouteByPath,\n  RouterState,\n  ToSubOptionsProps,\n} from '@tanstack/router-core'\n\ndeclare module '@tanstack/router-core' {\n  export interface RouteMatchExtensions {\n    meta?: Array<Solid.JSX.IntrinsicElements['meta'] | undefined>\n    links?: Array<Solid.JSX.IntrinsicElements['link'] | undefined>\n    scripts?: Array<Solid.JSX.IntrinsicElements['script'] | undefined>\n    headScripts?: Array<Solid.JSX.IntrinsicElements['script'] | undefined>\n  }\n}\n\nexport function Matches() {\n  const router = useRouter()\n\n  const pendingElement = router.options.defaultPendingComponent ? (\n    <router.options.defaultPendingComponent />\n  ) : null\n\n  // Do not render a root Suspense during SSR or hydrating from SSR\n  const ResolvedSuspense =\n    router.isServer || (typeof document !== 'undefined' && router.clientSsr)\n      ? SafeFragment\n      : Solid.Suspense\n\n  const inner = (\n    <ResolvedSuspense fallback={pendingElement}>\n      <Transitioner />\n      <MatchesInner />\n    </ResolvedSuspense>\n  )\n\n  return router.options.InnerWrap ? (\n    <router.options.InnerWrap>{inner}</router.options.InnerWrap>\n  ) : (\n    inner\n  )\n}\n\nfunction MatchesInner() {\n  const matchId = useRouterState({\n    select: (s) => {\n      return s.matches[0]?.id\n    },\n  })\n\n  const resetKey = useRouterState({\n    select: (s) => s.loadedAt,\n  })\n\n  return (\n    <matchContext.Provider value={matchId}>\n      <CatchBoundary\n        getResetKey={() => resetKey()}\n        errorComponent={ErrorComponent}\n        onCatch={(error) => {\n          warning(\n            false,\n            `The following error wasn't caught by any route! At the very least, consider setting an 'errorComponent' in your RootRoute!`,\n          )\n          warning(false, error.message || error.toString())\n        }}\n      >\n        {matchId() ? <Match matchId={matchId()!} /> : null}\n      </CatchBoundary>\n    </matchContext.Provider>\n  )\n}\n\nexport type UseMatchRouteOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends string = string,\n  TTo extends string | undefined = undefined,\n  TMaskFrom extends string = TFrom,\n  TMaskTo extends string = '',\n> = ToSubOptionsProps<TRouter, TFrom, TTo> &\n  DeepPartial<MakeOptionalSearchParams<TRouter, TFrom, TTo>> &\n  DeepPartial<MakeOptionalPathParams<TRouter, TFrom, TTo>> &\n  MaskOptions<TRouter, TMaskFrom, TMaskTo> &\n  MatchRouteOptions\n\nexport function useMatchRoute<TRouter extends AnyRouter = RegisteredRouter>() {\n  const router = useRouter()\n\n  const status = useRouterState({\n    select: (s) => s.status,\n  })\n\n  return <\n    const TFrom extends string = string,\n    const TTo extends string | undefined = undefined,\n    const TMaskFrom extends string = TFrom,\n    const TMaskTo extends string = '',\n  >(\n    opts: UseMatchRouteOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>,\n  ): Solid.Accessor<\n    false | Expand<ResolveRoute<TRouter, TFrom, TTo>['types']['allParams']>\n  > => {\n    const { pending, caseSensitive, fuzzy, includeSearch, ...rest } = opts\n\n    const matchRoute = Solid.createMemo(() => {\n      status()\n      return router.matchRoute(rest as any, {\n        pending,\n        caseSensitive,\n        fuzzy,\n        includeSearch,\n      })\n    })\n\n    return matchRoute\n  }\n}\n\nexport type MakeMatchRouteOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends string = string,\n  TTo extends string | undefined = undefined,\n  TMaskFrom extends string = TFrom,\n  TMaskTo extends string = '',\n> = UseMatchRouteOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // If a function is passed as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n  children?:\n    | ((\n        params?: RouteByPath<\n          TRouter['routeTree'],\n          ResolveRelativePath<TFrom, NoInfer<TTo>>\n        >['types']['allParams'],\n      ) => Solid.JSX.Element)\n    | Solid.JSX.Element\n}\n\nexport function MatchRoute<\n  TRouter extends AnyRouter = RegisteredRouter,\n  const TFrom extends string = string,\n  const TTo extends string | undefined = undefined,\n  const TMaskFrom extends string = TFrom,\n  const TMaskTo extends string = '',\n>(props: MakeMatchRouteOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>): any {\n  const status = useRouterState({\n    select: (s) => s.status,\n  })\n\n  return (\n    <Solid.Show when={status()} keyed>\n      {(_) => {\n        const matchRoute = useMatchRoute()\n        const params = matchRoute(props as any)() as boolean\n        const child = props.children\n        if (typeof child === 'function') {\n          return (child as any)(params)\n        }\n\n        return params ? child : null\n      }}\n    </Solid.Show>\n  )\n}\n\nexport interface UseMatchesBaseOptions<TRouter extends AnyRouter, TSelected> {\n  select?: (matches: Array<MakeRouteMatchUnion<TRouter>>) => TSelected\n}\n\nexport type UseMatchesResult<\n  TRouter extends AnyRouter,\n  TSelected,\n> = unknown extends TSelected ? Array<MakeRouteMatchUnion<TRouter>> : TSelected\n\nexport function useMatches<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n>(\n  opts?: UseMatchesBaseOptions<TRouter, TSelected>,\n): Solid.Accessor<UseMatchesResult<TRouter, TSelected>> {\n  return useRouterState({\n    select: (state: RouterState<TRouter['routeTree']>) => {\n      const matches = state.matches\n      return opts?.select\n        ? opts.select(matches as Array<MakeRouteMatchUnion<TRouter>>)\n        : matches\n    },\n  } as any) as Solid.Accessor<UseMatchesResult<TRouter, TSelected>>\n}\n\nexport function useParentMatches<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n>(\n  opts?: UseMatchesBaseOptions<TRouter, TSelected>,\n): Solid.Accessor<UseMatchesResult<TRouter, TSelected>> {\n  const contextMatchId = Solid.useContext(matchContext)\n\n  return useMatches({\n    select: (matches: Array<MakeRouteMatchUnion<TRouter>>) => {\n      matches = matches.slice(\n        0,\n        matches.findIndex((d) => d.id === contextMatchId()),\n      )\n      return opts?.select ? opts.select(matches) : matches\n    },\n  } as any)\n}\n\nexport function useChildMatches<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n>(\n  opts?: UseMatchesBaseOptions<TRouter, TSelected>,\n): Solid.Accessor<UseMatchesResult<TRouter, TSelected>> {\n  const contextMatchId = Solid.useContext(matchContext)\n\n  return useMatches({\n    select: (matches: Array<MakeRouteMatchUnion<TRouter>>) => {\n      matches = matches.slice(\n        matches.findIndex((d) => d.id === contextMatchId()) + 1,\n      )\n      return opts?.select ? opts.select(matches) : matches\n    },\n  } as any)\n}\n"],"names":["Matches","router","useRouter","pendingElement","options","defaultPendingComponent","_$createComponent","ResolvedSuspense","isServer","document","clientSsr","SafeFragment","Solid","Suspense","inner","fallback","children","Transitioner","MatchesInner","InnerWrap","matchId","useRouterState","select","s","matches","id","resetKey","loadedAt","matchContext","Provider","value","CatchBoundary","getResetKey","errorComponent","ErrorComponent","onCatch","error","warning","message","toString","_$memo","Match","useMatchRoute","status","opts","pending","caseSensitive","fuzzy","includeSearch","rest","matchRoute","createMemo","MatchRoute","props","Show","when","keyed","_","params","child","useMatches","state","useParentMatches","contextMatchId","useContext","slice","findIndex","d","useChildMatches"],"mappings":"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"}