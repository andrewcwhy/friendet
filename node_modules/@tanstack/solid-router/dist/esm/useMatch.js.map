{"version":3,"file":"useMatch.js","sources":["../../src/useMatch.tsx"],"sourcesContent":["import * as Solid from 'solid-js'\nimport invariant from 'tiny-invariant'\nimport { useRouterState } from './useRouterState'\nimport { dummyMatchContext, matchContext } from './matchContext'\nimport type {\n  AnyRouter,\n  MakeRouteMatch,\n  MakeRouteMatchUnion,\n  RegisteredRouter,\n  StrictOrFrom,\n  ThrowConstraint,\n  ThrowOrOptional,\n} from '@tanstack/router-core'\n\nexport interface UseMatchBaseOptions<\n  TRouter extends AnyRouter,\n  TFrom,\n  TStrict extends boolean,\n  TThrow extends boolean,\n  TSelected,\n> {\n  select?: (\n    match: MakeRouteMatch<TRouter['routeTree'], TFrom, TStrict>,\n  ) => TSelected\n  shouldThrow?: TThrow\n}\n\nexport type UseMatchRoute<out TFrom> = <\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n>(\n  opts?: UseMatchBaseOptions<TRouter, TFrom, true, true, TSelected>,\n) => Solid.Accessor<UseMatchResult<TRouter, TFrom, true, TSelected>>\n\nexport type UseMatchOptions<\n  TRouter extends AnyRouter,\n  TFrom extends string | undefined,\n  TStrict extends boolean,\n  TThrow extends boolean,\n  TSelected,\n> = StrictOrFrom<TRouter, TFrom, TStrict> &\n  UseMatchBaseOptions<TRouter, TFrom, TStrict, TThrow, TSelected>\n\nexport type UseMatchResult<\n  TRouter extends AnyRouter,\n  TFrom,\n  TStrict extends boolean,\n  TSelected,\n> = unknown extends TSelected\n  ? TStrict extends true\n    ? MakeRouteMatch<TRouter['routeTree'], TFrom, TStrict>\n    : MakeRouteMatchUnion<TRouter>\n  : TSelected\n\nexport function useMatch<\n  TRouter extends AnyRouter = RegisteredRouter,\n  const TFrom extends string | undefined = undefined,\n  TStrict extends boolean = true,\n  TThrow extends boolean = true,\n  TSelected = unknown,\n>(\n  opts: UseMatchOptions<\n    TRouter,\n    TFrom,\n    TStrict,\n    ThrowConstraint<TStrict, TThrow>,\n    TSelected\n  >,\n): Solid.Accessor<\n  ThrowOrOptional<UseMatchResult<TRouter, TFrom, TStrict, TSelected>, TThrow>\n> {\n  const nearestMatchId = Solid.useContext(\n    opts.from ? dummyMatchContext : matchContext,\n  )\n\n  const matchSelection = useRouterState({\n    select: (state: any) => {\n      const match = state.matches.find((d: any) =>\n        opts.from ? opts.from === d.routeId : d.id === nearestMatchId(),\n      )\n\n      invariant(\n        !((opts.shouldThrow ?? true) && !match),\n        `Could not find ${opts.from ? `an active match from \"${opts.from}\"` : 'a nearest match!'}`,\n      )\n\n      if (match === undefined) {\n        return undefined\n      }\n\n      return opts.select ? opts.select(match) : match\n    },\n  } as any)\n\n  return matchSelection as any\n}\n"],"names":["useMatch","opts","nearestMatchId","Solid","useContext","from","dummyMatchContext","matchContext","matchSelection","useRouterState","select","state","match","matches","find","d","routeId","id","invariant","shouldThrow","undefined"],"mappings":";;;;AAsDO,SAASA,SAOdC,MASA;AACA,QAAMC,iBAAiBC,MAAMC,WAC3BH,KAAKI,OAAOC,oBAAoBC,YAClC;AAEA,QAAMC,iBAAiBC,eAAe;AAAA,IACpCC,QAAQA,CAACC,UAAe;AACtB,YAAMC,QAAQD,MAAME,QAAQC,KAAK,CAACC,MAChCd,KAAKI,OAAOJ,KAAKI,SAASU,EAAEC,UAAUD,EAAEE,OAAOf,gBACjD;AAEAgB,gBACE,GAAGjB,KAAKkB,eAAe,SAAS,CAACP,QACjC,kBAAkBX,KAAKI,OAAO,yBAAyBJ,KAAKI,IAAI,MAAM,kBAAkB,EAC1F;AAEA,UAAIO,UAAUQ,QAAW;AAChBA,eAAAA;AAAAA,MAAAA;AAGT,aAAOnB,KAAKS,SAAST,KAAKS,OAAOE,KAAK,IAAIA;AAAAA,IAAAA;AAAAA,EAC5C,CACM;AAEDJ,SAAAA;AACT;"}