import { createComponent, memo, Dynamic, mergeProps } from "solid-js/web";
import * as Solid from "solid-js";
import invariant from "tiny-invariant";
import warning from "tiny-warning";
import { isNotFound, rootRouteId, pick, isRedirect, createControlledPromise, getLocationChangeInfo } from "@tanstack/router-core";
import { ErrorComponent, CatchBoundary } from "./CatchBoundary.js";
import { useRouterState } from "./useRouterState.js";
import { useRouter } from "./useRouter.js";
import { CatchNotFound } from "./not-found.js";
import { matchContext } from "./matchContext.js";
import { SafeFragment } from "./SafeFragment.js";
import { renderRouteNotFound } from "./renderRouteNotFound.js";
import { ScrollRestoration } from "./scroll-restoration.js";
const Match = (props) => {
  const router = useRouter();
  const routeId = useRouterState({
    select: (s) => {
      var _a;
      return (_a = s.matches.find((d) => d.id === props.matchId)) == null ? void 0 : _a.routeId;
    }
  });
  invariant(routeId, `Could not find routeId for matchId "${props.matchId}". Please file an issue!`);
  const route = () => router.routesById[routeId()];
  const PendingComponent = () => route().options.pendingComponent ?? router.options.defaultPendingComponent;
  const routeErrorComponent = () => route().options.errorComponent ?? router.options.defaultErrorComponent;
  const routeOnCatch = () => route().options.onCatch ?? router.options.defaultOnCatch;
  const routeNotFoundComponent = () => {
    var _a;
    return route().isRoot ? (
      // If it's the root route, use the globalNotFound option, with fallback to the notFoundRoute's component
      route().options.notFoundComponent ?? ((_a = router.options.notFoundRoute) == null ? void 0 : _a.options.component)
    ) : route().options.notFoundComponent;
  };
  const ResolvedSuspenseBoundary = () => {
    var _a;
    return (
      // If we're on the root route, allow forcefully wrapping in suspense
      (!route().isRoot || route().options.wrapInSuspense) && (route().options.wrapInSuspense ?? PendingComponent() ?? ((_a = route().options.errorComponent) == null ? void 0 : _a.preload)) ? Solid.Suspense : SafeFragment
    );
  };
  const ResolvedCatchBoundary = () => routeErrorComponent() ? CatchBoundary : SafeFragment;
  const ResolvedNotFoundBoundary = () => routeNotFoundComponent() ? CatchNotFound : SafeFragment;
  const resetKey = useRouterState({
    select: (s) => s.loadedAt
  });
  const parentRouteId = useRouterState({
    select: (s) => {
      var _a;
      const index = s.matches.findIndex((d) => d.id === props.matchId);
      return (_a = s.matches[index - 1]) == null ? void 0 : _a.routeId;
    }
  });
  const ShellComponent = route().isRoot ? route().options.shellComponent ?? SafeFragment : SafeFragment;
  return createComponent(ShellComponent, {
    get children() {
      return [createComponent(matchContext.Provider, {
        value: () => props.matchId,
        get children() {
          return createComponent(Dynamic, {
            get component() {
              return ResolvedSuspenseBoundary();
            },
            get fallback() {
              return createComponent(Dynamic, {
                get component() {
                  return PendingComponent();
                }
              });
            },
            get children() {
              return createComponent(Dynamic, {
                get component() {
                  return ResolvedCatchBoundary();
                },
                getResetKey: () => resetKey(),
                get errorComponent() {
                  return routeErrorComponent() || ErrorComponent;
                },
                onCatch: (error) => {
                  var _a;
                  if (isNotFound(error)) throw error;
                  warning(false, `Error in route match: ${props.matchId}`);
                  (_a = routeOnCatch()) == null ? void 0 : _a(error);
                },
                get children() {
                  return createComponent(Dynamic, {
                    get component() {
                      return ResolvedNotFoundBoundary();
                    },
                    fallback: (error) => {
                      if (!routeNotFoundComponent() || error.routeId && error.routeId !== routeId || !error.routeId && !route().isRoot) throw error;
                      return createComponent(Dynamic, mergeProps({
                        get component() {
                          return routeNotFoundComponent();
                        }
                      }, error));
                    },
                    get children() {
                      return createComponent(MatchInner, {
                        get matchId() {
                          return props.matchId;
                        }
                      });
                    }
                  });
                }
              });
            }
          });
        }
      }), memo(() => memo(() => parentRouteId() === rootRouteId)() ? [createComponent(OnRendered, {}), createComponent(ScrollRestoration, {})] : null)];
    }
  });
};
function OnRendered() {
  const router = useRouter();
  const location = useRouterState({
    select: (s) => {
      var _a;
      return (_a = s.resolvedLocation) == null ? void 0 : _a.state.__TSR_key;
    }
  });
  Solid.createEffect(Solid.on([location], () => {
    router.emit({
      type: "onRendered",
      ...getLocationChangeInfo(router.state)
    });
  }));
  return null;
}
const MatchInner = (props) => {
  const router = useRouter();
  const matchState = useRouterState({
    select: (s) => {
      const matchIndex = s.matches.findIndex((d) => d.id === props.matchId);
      const match2 = s.matches[matchIndex];
      const routeId = match2.routeId;
      const remountFn = router.routesById[routeId].options.remountDeps ?? router.options.defaultRemountDeps;
      const remountDeps = remountFn == null ? void 0 : remountFn({
        routeId,
        loaderDeps: match2.loaderDeps,
        params: match2._strictParams,
        search: match2._strictSearch
      });
      const key = remountDeps ? JSON.stringify(remountDeps) : void 0;
      return {
        key,
        routeId,
        match: pick(match2, ["id", "status", "error"])
      };
    }
  });
  const route = () => router.routesById[matchState().routeId];
  const match = () => matchState().match;
  const out = () => {
    const Comp = route().options.component ?? router.options.defaultComponent;
    if (Comp) {
      return createComponent(Comp, {});
    }
    return createComponent(Outlet, {});
  };
  return createComponent(Solid.Switch, {
    get children() {
      return [createComponent(Solid.Match, {
        get when() {
          return match().status === "notFound";
        },
        children: (_) => {
          invariant(isNotFound(match().error), "Expected a notFound error");
          return renderRouteNotFound(router, route(), match().error);
        }
      }), createComponent(Solid.Match, {
        get when() {
          return match().status === "redirected";
        },
        children: (_) => {
          invariant(isRedirect(match().error), "Expected a redirect error");
          const [loaderResult] = Solid.createResource(async () => {
            var _a;
            await new Promise((r) => setTimeout(r, 0));
            return (_a = router.getMatch(match().id)) == null ? void 0 : _a.loadPromise;
          });
          return memo(loaderResult);
        }
      }), createComponent(Solid.Match, {
        get when() {
          return match().status === "error";
        },
        children: (_) => {
          if (router.isServer) {
            const RouteErrorComponent = (route().options.errorComponent ?? router.options.defaultErrorComponent) || ErrorComponent;
            return createComponent(RouteErrorComponent, {
              get error() {
                return match().error;
              },
              info: {
                componentStack: ""
              }
            });
          }
          throw match().error;
        }
      }), createComponent(Solid.Match, {
        get when() {
          return match().status === "pending";
        },
        children: (_) => {
          var _a;
          const pendingMinMs = route().options.pendingMinMs ?? router.options.defaultPendingMinMs;
          if (pendingMinMs && !((_a = router.getMatch(match().id)) == null ? void 0 : _a.minPendingPromise)) {
            if (!router.isServer) {
              const minPendingPromise = createControlledPromise();
              Promise.resolve().then(() => {
                router.updateMatch(match().id, (prev) => ({
                  ...prev,
                  minPendingPromise
                }));
              });
              setTimeout(() => {
                minPendingPromise.resolve();
                router.updateMatch(match().id, (prev) => ({
                  ...prev,
                  minPendingPromise: void 0
                }));
              }, pendingMinMs);
            }
          }
          const [loaderResult] = Solid.createResource(async () => {
            var _a2;
            await new Promise((r) => setTimeout(r, 0));
            return (_a2 = router.getMatch(match().id)) == null ? void 0 : _a2.loadPromise;
          });
          return memo(loaderResult);
        }
      }), createComponent(Solid.Match, {
        get when() {
          return match().status === "success";
        },
        get children() {
          return out();
        }
      })];
    }
  });
};
const Outlet = () => {
  const router = useRouter();
  const matchId = Solid.useContext(matchContext);
  const routeId = useRouterState({
    select: (s) => {
      var _a;
      return (_a = s.matches.find((d) => d.id === matchId())) == null ? void 0 : _a.routeId;
    }
  });
  const route = () => router.routesById[routeId()];
  const parentGlobalNotFound = useRouterState({
    select: (s) => {
      const matches = s.matches;
      const parentMatch = matches.find((d) => d.id === matchId());
      invariant(parentMatch, `Could not find parent match for matchId "${matchId()}"`);
      return parentMatch.globalNotFound;
    }
  });
  const childMatchId = useRouterState({
    select: (s) => {
      var _a;
      const matches = s.matches;
      const index = matches.findIndex((d) => d.id === matchId());
      const v = (_a = matches[index + 1]) == null ? void 0 : _a.id;
      return v;
    }
  });
  return createComponent(Solid.Switch, {
    get children() {
      return [createComponent(Solid.Match, {
        get when() {
          return router.isShell;
        },
        get children() {
          return createComponent(Solid.Suspense, {
            get fallback() {
              return createComponent(Dynamic, {
                get component() {
                  return router.options.defaultPendingComponent;
                }
              });
            },
            get children() {
              return createComponent(ErrorComponent, {
                error: new Error("ShellBoundaryError")
              });
            }
          });
        }
      }), createComponent(Solid.Match, {
        get when() {
          return parentGlobalNotFound();
        },
        get children() {
          return renderRouteNotFound(router, route(), void 0);
        }
      }), createComponent(Solid.Match, {
        get when() {
          return childMatchId();
        },
        children: (matchId2) => {
          return createComponent(Solid.Show, {
            get when() {
              return matchId2() === rootRouteId;
            },
            get fallback() {
              return createComponent(Match, {
                get matchId() {
                  return matchId2();
                }
              });
            },
            get children() {
              return createComponent(Solid.Suspense, {
                get fallback() {
                  return createComponent(Dynamic, {
                    get component() {
                      return router.options.defaultPendingComponent;
                    }
                  });
                },
                get children() {
                  return createComponent(Match, {
                    get matchId() {
                      return matchId2();
                    }
                  });
                }
              });
            }
          });
        }
      })];
    }
  });
};
export {
  Match,
  MatchInner,
  Outlet
};
//# sourceMappingURL=Match.js.map
